# 🔄 协作式续写功能设计

## 📋 需求说明

### 当前问题
- Fork创建独立故事，首页显示多个版本
- 视频只包含单个用户的内容

### 新需求
1. 续写应该**添加到原故事**，而不是创建新故事
2. 首页只显示**一个原创故事**
3. 点击查看时，显示**原作者+所有续写者**的完整内容
4. 生成视频使用**完整的合并内容**
5. 只有**原作者**可以生成视频

---

## 🗄️ 数据库设计修改

### 方案A: 添加续写贡献表（推荐）

```sql
-- 原创故事表（保持不变）
CREATE TABLE stories (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    title TEXT NOT NULL,
    author TEXT NOT NULL,
    content TEXT NOT NULL,  -- 原作者的内容
    max_contributors INTEGER DEFAULT 5,
    contribution_count INTEGER DEFAULT 0,  -- 已有多少人续写
    video_url TEXT,
    video_status TEXT DEFAULT 'none',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 新增：续写贡献表
CREATE TABLE story_contributions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    story_id INTEGER NOT NULL,
    author TEXT NOT NULL,
    content TEXT NOT NULL,
    order_index INTEGER NOT NULL,  -- 续写顺序
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (story_id) REFERENCES stories(id) ON DELETE CASCADE
);
```

### 方案B: 简化版（使用现有表结构）

保持现有表结构，但修改逻辑：
- `parent_id != null` 的记录是续写内容
- 显示时合并 parent + 所有 children 的 content
- 首页只显示 `parent_id = null` 的故事

**我建议使用方案B**，因为数据库结构已经存在，只需修改查询和显示逻辑。

---

## 🔧 实现方案（使用方案B）

### 后端修改

#### 1. 添加获取完整故事内容的接口

```python
@app.get("/api/stories/{story_id}/full-content")
def get_full_story_content(story_id: int):
    """
    获取故事的完整内容（原创+所有续写）
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 获取原创故事
        cursor.execute("SELECT * FROM stories WHERE id = ?", (story_id,))
        original = cursor.fetchone()
        
        if not original:
            conn.close()
            raise HTTPException(status_code=404, detail="故事不存在")
        
        # 获取所有续写（按创建时间排序）
        cursor.execute(
            """
            SELECT author, content, created_at 
            FROM stories 
            WHERE parent_id = ? 
            ORDER BY created_at ASC
            """,
            (story_id,)
        )
        contributions = cursor.fetchall()
        conn.close()
        
        # 构建完整内容
        full_content = original["content"]
        contribution_list = []
        
        for contrib in contributions:
            full_content += "\n\n" + contrib["content"]
            contribution_list.append({
                "author": contrib["author"],
                "content": contrib["content"],
                "created_at": contrib["created_at"]
            })
        
        return {
            "story_id": story_id,
            "title": original["title"],
            "original_author": original["author"],
            "original_content": original["content"],
            "contributions": contribution_list,
            "full_content": full_content,
            "contribution_count": len(contribution_list),
            "max_contributors": original["max_contributors"]
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取完整内容失败: {str(e)}")
```

#### 2. 修改获取故事列表接口

```python
@app.get("/api/stories", response_model=List[StoryResponse])
def get_stories(
    filter_by: str = "all",
    sort_by: str = "created_at",
    limit: int = 50
):
    """
    获取故事列表（只返回原创故事，不包含续写）
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 只查询原创故事（parent_id 为 NULL）
        where_clause = "WHERE parent_id IS NULL"
        
        if filter_by == "with_video":
            where_clause += " AND video_status = 'completed'"
        
        # 验证排序字段
        if sort_by not in ["created_at", "fork_count"]:
            sort_by = "created_at"
        
        query = f"""
            SELECT * FROM stories 
            {where_clause}
            ORDER BY {sort_by} DESC 
            LIMIT ?
        """
        
        cursor.execute(query, (limit,))
        rows = cursor.fetchall()
        conn.close()
        
        return [dict_from_row(row) for row in rows]
    
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"获取故事列表失败: {str(e)}")
```

#### 3. 修改视频生成接口

```python
@app.post("/api/stories/{story_id}/generate-video")
def generate_video_for_story(
    story_id: int, 
    request: GenerateVideoRequest,
    background_tasks: BackgroundTasks
):
    """
    为故事生成视频（使用完整内容：原创+所有续写）
    """
    try:
        conn = get_db_connection()
        cursor = conn.cursor()
        
        # 获取原创故事
        cursor.execute("SELECT * FROM stories WHERE id = ?", (story_id,))
        story = cursor.fetchone()
        
        if not story:
            conn.close()
            raise HTTPException(status_code=404, detail="故事不存在")
        
        # 验证作者身份
        if story["author"] != request.author:
            conn.close()
            raise HTTPException(status_code=403, detail="只有故事原作者可以生成视频")
        
        # 检查是否已经在生成中
        if story["video_status"] == "generating":
            conn.close()
            raise HTTPException(status_code=400, detail="视频正在生成中，请稍候")
        
        # 获取完整内容（原创+所有续写）
        cursor.execute(
            "SELECT content FROM stories WHERE parent_id = ? ORDER BY created_at ASC",
            (story_id,)
        )
        contributions = cursor.fetchall()
        
        # 合并所有内容
        full_content = story["content"]
        for contrib in contributions:
            full_content += "\n\n" + contrib["content"]
        
        # 更新状态为生成中
        cursor.execute(
            "UPDATE stories SET video_status = 'generating' WHERE id = ?",
            (story_id,)
        )
        conn.commit()
        conn.close()
        
        # 后台任务：使用完整内容生成视频
        background_tasks.add_task(generate_video_task, story_id, full_content)
        
        print(f"🎬 视频生成任务已启动: story_id={story_id}, author={request.author}")
        print(f"📝 使用完整内容（包含 {len(contributions)} 个续写）")
        
        return {
            "message": "视频生成任务已启动（包含所有续写内容）",
            "story_id": story_id,
            "status": "generating",
            "total_contributions": len(contributions)
        }
    
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"生成视频失败: {str(e)}")
```

---

## 🎨 前端修改

### 1. 修改 api.js

```javascript
// 获取故事完整内容（包含所有续写）
export const getFullStoryContent = async (id) => {
  const response = await api.get(`/stories/${id}/full-content`)
  return response.data
}
```

### 2. 修改 HomePage.jsx

```javascript
// 首页只显示原创故事
// API已经自动过滤，无需前端修改
```

### 3. 修改 StoryDetailPage.jsx

```jsx
import { getFullStoryContent } from '../api/api'

function StoryDetailPage() {
  const [fullStory, setFullStory] = useState(null)
  
  const loadStory = async () => {
    try {
      setLoading(true)
      const data = await getFullStoryContent(id)
      setFullStory(data)
      
      // 同时获取基础信息（用于视频状态等）
      const basicData = await getStory(id)
      setStory(basicData)
    } catch (err) {
      setError('加载故事失败')
    } finally {
      setLoading(false)
    }
  }
  
  return (
    <div>
      {/* 原作者 */}
      <h1>{fullStory.title}</h1>
      <p>👤 原作者: {fullStory.original_author}</p>
      
      {/* 原创内容 */}
      <div className="story-section">
        <h3>📖 {fullStory.original_author} 的原创内容</h3>
        <p>{fullStory.original_content}</p>
      </div>
      
      {/* 续写内容 */}
      {fullStory.contributions.map((contrib, index) => (
        <div key={index} className="story-section contribution">
          <h3>✍️ {contrib.author} 的续写</h3>
          <p>{contrib.content}</p>
          <small>{new Date(contrib.created_at).toLocaleString()}</small>
        </div>
      ))}
      
      {/* 提示信息 */}
      <p>
        📝 续写情况: {fullStory.contribution_count}/{fullStory.max_contributors} 人
      </p>
      
      {/* 生成视频按钮（只有原作者可见） */}
      {story.author === userNickname && (
        <button onClick={handleGenerateVideo}>
          🎬 生成视频（包含所有续写内容）
        </button>
      )}
    </div>
  )
}
```

---

## 📊 效果对比

### 旧逻辑（Fork）

**首页显示**:
```
1. 中关村 - ssh
2. 中关村（续）- B  
3. 中关村（续2）- C
```

**视频内容**: 只包含单个用户的内容

### 新逻辑（协作续写）

**首页显示**:
```
1. 中关村 - ssh (2/5人续写)
```

**详情页显示**:
```
┌─ 中关村 ─────────────────────┐
│ 👤 原作者: ssh               │
├──────────────────────────────┤
│ 📖 ssh 的原创内容            │
│ 这是关于中关村的故事...      │
├──────────────────────────────┤
│ ✍️ B 的续写                  │
│ 然后发生了有趣的事情...      │
├──────────────────────────────┤
│ ✍️ C 的续写                  │
│ 故事继续发展...              │
└──────────────────────────────┘

📝 续写情况: 2/5 人
[🤖 AI 润色] [✍️ 续写这个故事]

（ssh可见）[🎬 生成视频（包含所有内容）]
```

**视频内容**: ssh + B + C 的完整故事

---

## ⚡ 快速实施

这个改动需要修改：
1. 后端 3 个接口
2. 前端 2 个文件

是否需要我立即实现这些修改？

